### 0. 배열이란

**배열(Array)** 

 연관된 데이터를 연속된 메모리에 미리 할당된 크기만큼 저장하는 자료구조(순차적으로 데이터가 저장됨)

**배열의 특징**

- 배열은 같은 타입의 데이터를 여러개 나열한 선형 자료구조이다.
- int 타입으로 선언되었다 하면, 동일 타입 즉 int 타입의 데이터를 순차적으로 저장한다.
- 생성할때, 배열의 크기를 정한다면, 해당 크기는 고정이 된다. (=미리 할당된크기만큼 저장)
- 배열을 구성하는 각각의 값을 원소라고 하며, 배열 에서의 위치를 가리키는 숫자는 인덱스라고 한다.
    
    e.g.) index 0 에 위치한 요소는 1이다. 
    이에, 인덱스를 사용하여 각 원소를 접근해 나갈 수 있음
    

### 1. 배열의 선언 방법

`int[] arr1 = new int[5];`

해당 배열의 자료형과 크기 지정 
e.g) int (자료형 ) + arr1(변수명) = new int[5] (크기지정)

** new : 배열이나 객체를 생성하면, JVM (자바 가상 머신) 이 힙 메모리 영역에 필요한 크기의 메모리를 할당함. <br>
e.x) new int[5] 는 int 타입의 요소 5개가 들어갈 메모리 공간을 힙 메모리에 할당함. 

### 배열의 복사

**주소를 복사하는 경우 == 배열의 얕은 복사** 

```java
int [] a = {1,2,3,4,5};
int [] b 
b = a; 
b[0] = 10;
System.out.println(Arrays.toString(a))
/*[10,2,3,4,5]
(얕은 복사를 하면 새로운 배열을 생성하는 것이 아니라, 기존 배열을 가리키는 잠조만 복사하는것이기에
b의 값을 바꾸면 a의 배열의 값이 영향을 받음) */
```

**요소 값을 복사하는 경우 == 배열의 깊은 복사**

```java
int[] a = {1, 2, 3, 4, 5};
int[] b; // 배열 선언
b = a.clone(); // clone() 메소드를 사용하여 깊은 복사(깊은복사는 a,b와 독립된 배열)
System.out.println(Arrays.toString(b))
//[1,2,3,4,5]
b[0] = 10; 
System.out.println(Arrays.toString(b))
/*[10,2,3,4,5]
(독립된 배열이기때문에, b의 값을 바꿔도 a의 배열의 값은 영향을 받지않음.)
*/
```

### 2. 배열의 시간복잡도

### 시간복잡도

코드의 실행 시간이 어떤 요인으로 결정되는지 나타내는 시간과 입력 데이터의 함수

**시간복잡도의 표현**

- 빅오(Big - O) 표기법을 사용하여 표현
- 빅오 표기법은 알고리즘이 겪을 수 있는 최악의 경우에 걸리는 시간과 입력 간의 상관 관계를 표기
- 입력 크기가 N이면, 이에 비례하는 시간이 걸린다면 O(N)으로 표기
- 단순 연산의 시간 복잡도 상수 시간 : O(1)로 표기

### 배열의 시간 복잡도

| Operation | average case | worst case |
| --- | --- | --- |
| read | O(1) | O(1) |
| insert | O(N)  | O(N)  |
| delete | O(N)  | O(N)  |
| search | O(N)  | O(N)  |

> **배열의 접근(read)** 
 O(1)의 시간 복잡도를 갖음. 찾고자 하는 값의 인덱스 값을 알고 있다면 빠른 속도를 갖는다
> 

> **배열의 검색(search)** 
배열의 검색은 순차검색 이므로 인덱스를 알지 못할 때 원하는 값을 찾기 위해 배열을 하나하나 확인해야함. 
O(N) 의 시간 복잡도를 갖음 → 경우에 따라 다름 (e.g. 인덱스를 알고 있을때 (=빠른속도), 모르고 있을때 (배열의 크기에 따라 다름)
> 

> **배열의 추가 및 삭제 (Insert / Delete)**
어떠한 인덱스 원소를 추가하고 삭제하려고하는데, 인덱스를 모르는 경우에는 ,해당하는 인덱스를 찾아야 하는 경우가 발생한다. 검색의 시간복잡도인 O(N)이 해당이 됨. 
인덱스 값을 알고 있다면, 접근의 개념이 들어가 O(1)의 시간 복잡도가 해당 됨
> 

```markdown
CS 예상 문제 1)
**배열의 접근이 어떻게 이루어지길래 O(1)이 되는 것인가 ?**
-> base-address + offset 연산으로 특정 인덱스의 주소를 바로 계산할 수있음. 이에 따라 인덱스 값을 
알수 있기때문에, 하나하나 확인을 할 필요성이 없기에 O(1)이 됨.
-> base-address는 배열의 시작 주소이고, offset은 indx (-Size) 로 계산해나감. 

CS예상 문제 2)
**미리 예상한 것보다 더 많은 수의 data를 저장하느라 Array의 Size를 넘어서게 되었다. 어떻게 해결할 수있는것인가?
->** 배열의 특징상, 배열을 생성할떄, 배열의 크기를 결정하고, 결정된 크기는 해당 배열에서 고정된 크기가 된다. 
그렇기 때문에, 기존 배열을 copy 하여 더 큰 사이즈의 배열을 선언해 옮겨 나머지 데이터를 할당한다. 
그리고 그 전의 기존의 배열은 필요가 없기때문에, 메모리상 삭제한다. 
Size를 예측하기 어려운 상태라면 배열 대신 ArrayList를 사용하여 데이터 추가할때 마다 메모리를 할당하는 방식으로 변경한다**.** 

```

